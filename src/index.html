<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
</head>
<body>
<br>
<input type="file" id="uploadFile" name="file" />
<br><br>
<label for="deviceID">Device ID:</label><br>
<input type="text" id="deviceID" name="deviceID" value=""><br>
<span id="uploadButton">
    <button id="upload">Upload</button>
</span>  
<br><br>
<span id="boardListButton">
    <button id="boardList">Board list</button>
</span>
<span id="cancelButton" style="display: none;">
  <button id="cancel" style="color: red">CANCEL</button>
</span>

<br>
<br>
Upload %: <output id="pct"></output>
<br>
<br>
Status Messages: <output id="list"></output>
<br>
<br>
Boards: <output id="boards"></output>
</body>
<script>
    var curDeviceID;
    var filePos;
    var file;
    var blob;
    var cancel = false;
    var boardsArr = [];
    //Event is used to wrap all messages Send and Recieved
    //on the Websocket
        //The type is used as a RPC
    class Event {
        // Each Event needs a Type
        // The payload is not required
        constructor(type, payload) {
            this.type = type;
            this.payload = payload;
        }
    }
    class Device {
        constructor(id, name, controller, programmer, port){
            this.id = id;
            this.name = name;
            this.controller = controller;
            this.programmer = programmer;
            this.port = port; 
        }
    }
    class FlashStart {
        constructor(id, fileSize){
            this.deviceID = id;
            this.fileSize = fileSize;
        }
    }
    class FlashBlock{
        constructor(blockID, data){
            this.blockID = blockID;
            this.data = data;
        }
    }
    function routeEvent(event) {
        if (event.type === undefined) {
            alert("no 'type' field in event");
        }
        switch (event.type) {
            case "device":
                // Format payload
                const deviceEvent = Object.assign(new Device, event.payload);
                document.getElementById('boards').innerHTML = '';
                boardsArr.push(JSON.stringify(event.payload));
                document.getElementById('boards').innerHTML = '<ul>' + boardsArr + '</ul>';
                break;
            case "flash-go":
                uploadFile();
                break;
            case "flash-done":
                alert("flash-done!")
                break;
            default:
                alert("unsupported message type");
                break;
        }
    }
    function sendEvent(eventName, payload) {
        // Create a event Object with a event named send_message
        const event = new Event(eventName, payload);
        // Format as JSON and send
        conn.send(JSON.stringify(event));
        console.log(JSON.stringify(event));
    }
    function startUploadFile(){
        var files = document.getElementById('uploadFile').files;
        if (!files.length) {
            alert('Please select a file!');
            return;
        }

        file = files[0];
        curDeviceID = document.getElementById('deviceID').value;
        msgData = new FlashStart(curDeviceID, file.size);
        sendEvent("flash-start", msgData);
        filePos = 0;
        reader = new FileReader();
    }
    function uploadFile(){
        var files = document.getElementById('uploadFile').files;
        if (!files.length) {
            alert('Please select a file!');
            return;
        }
        file = files[0];
        filePos = 0;
        var blockSize = 1024*1024;
        //var readerText = new FileReader();
        var msgBlock = new FlashBlock(0, "");
        var blob;
        /*readerText.addEventListener('loadend', (e) => {
            const text = e.srcElement.result;
            msgBlock.data = text;
            sendEvent("flash-block", msgBlock);
        });*/
        for (let i = 0; i < file.size; i+=blockSize){
            var first = i;
            var last = first + blockSize;
            if (last > file.size) {
                last = file.size;
            }
            console.log(first, last, file.size);
            blob = file.slice(first, last);
            msgBlock.blockID = i;
            var reader = new FileReader();
            reader.readAsDataURL(blob); 
            reader.onloadend = function() {
                var base64data = reader.result; 
                msgBlock.data = base64data.substr(base64data.indexOf(',')+1);
                console.log(msgBlock.blockID);  
                //console.log(msgBlock.data);   
                sendEvent("flash-block", msgBlock);            
            }
        }
    }
    window.onload = function (){
        // Check if the browser supports WebSocket
        if (window["WebSocket"]) {
            console.log("supports websockets");
            // Connect to websocket
            conn = new WebSocket("ws://" + document.location.host + "/flasher");

            // Add a listener to the onmessage event
            conn.onmessage = function (evt) {
                console.log(evt);
                // parse websocket message as JSON
                const eventData = JSON.parse(evt.data);
                // Assign JSON data to new Event Object
                const event = Object.assign(new Event, eventData);
                // Let router manage message
                routeEvent(event);
            }
            //document.getElementById('deviceID').onsubmit = uploadFile();
            document.querySelector('#boardList').addEventListener('click', function(evt){
                boardsArr = [];
                sendEvent('get-list', '');
            }, false);
            document.querySelector('#upload').addEventListener('click', startUploadFile, false);
        } else {
            alert("Not supporting websockets");
        }
        
    };
</script>
</html>
